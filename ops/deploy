#! /usr/bin/env bash

# Uncomment to help with debugging:
set -x

set -eo pipefail

TESTING="${3:-false}"

set -u

BASE_DIR="$1"
MAGNITUDE="$2"

# Ensure that we are within the source tree.
#
SRC="$(git rev-parse --show-toplevel)"

# If we fail, we want a back trace.
#
export RUST_BACKTRACE=1

# Confirm that the binary is present and working.
#
BIN="$SRC"/result/bin/mina-indexer
"$BIN" --version

# Differentiate some files/directories using the Git revision.
#
REV="$(git rev-parse --short=8 HEAD)"

# Operate from this directory.
#
mkdir -p "$BASE_DIR"
cd "$BASE_DIR"

# Ensure that the log directory exists.
#
LOGS=./logs/"$REV"
mkdir -p "$LOGS"

# Configure the $BLOCKS directory, downloading blocks from the
# granola-mina-blocks Linode bucket if need be. Note that the prior
# mina-indexer instance may start to read these blocks, if it is running.
#
BLOCKS="$BASE_DIR"/blocks
"$SRC"/ops/download-mina-blocks "$MAGNITUDE" "$BLOCKS"

# Download the staking ledgers if needed.
#
LEDGERS="$BASE_DIR"/staking-ledgers
"$SRC"/ops/download-staking-ledgers "$LEDGERS"

# Configure the socket.
#
SOCKET=./mina-indexer-"$REV".sock
wait_for_socket() {
    while true; do
        if [ -S "$SOCKET" ]; then
            return
        fi
        sleep 60
    done
}

ephemeral_port() {
    set +e
    LOW_BOUND=49152
    RANGE=16384
    while true; do
        CANDIDATE=$(( LOW_BOUND + (RANDOM % RANGE) ))
        if ! (echo "" >/dev/tcp/127.0.0.1/${CANDIDATE}) >/dev/null 2>&1; then
            echo $CANDIDATE
            break
        fi
    done
    set -e
}
port="$(ephemeral_port)"

# Construct the database. Ingest all blocks.
#
DB_DIR=./databases/"$REV"
"${BIN}" \
  --socket "$SOCKET" \
  server start \
    --web-port "$port" \
    --log-level DEBUG \
    --database-dir "$DB_DIR" \
    --blocks-dir "$BLOCKS" \
    --staking-ledgers-dir "$LEDGERS" \
    --ledger-cadence 5000 \
    > "$LOGS"/out \
    2> "$LOGS"/err \
    &
PID=$!
wait_for_socket

# Tell the server to take a snapshot (checkpoint).
#
SNAPSHOT="$BASE_DIR"/"$REV"-snapshot
"${BIN}" --socket "$SOCKET" checkpoints create --path "$SNAPSHOT"

# Then shut it down.
#
"${BIN}" --socket "$SOCKET" shutdown
wait "$PID"

if [ "$TESTING" == false ]; then
  # Terminate the prior production instance using the socket, if any. This will
  # not work if we change the on-wire comms protocol for the shutdown command,
  # note.
  #
  SOCKET=./mina-indexer.sock
  if [ -e "$SOCKET" ]; then
      if "$BIN" --socket "$SOCKET" shutdown
      then
          :
      fi
      sleep 1  # Allow the prior indexer some time to remove the socket without
               # surprising it by removing it, ourselves.
      rm -f "$SOCKET"
  fi

  # We must daemonize. This requires forking a child in a new session. This is
  # done with 'setsid'. The child must itself create a grandchild that is the
  # mina-indexer. We use a shell invocation with a terminal '&' to fork that
  # second time. Do not attempt to "simplify" this unless you really know what
  # you are doing.
  #
  setsid \
    sh -c \
      '"$@" 0< /dev/null 1>> '"$LOGS"'/out 2>> '"$LOGS"'/err &' \
      -- \
      "$BIN" \
        --socket "$SOCKET" \
        server start \
          --log-level DEBUG \
          --web-hostname 0.0.0.0 \
          --database-dir "$DB_DIR" \
          --blocks-dir "$BLOCKS" \
          --staking-ledgers-dir "$LEDGERS" \
    &

  # Wait for the above to return, otherwise the above fork'd process may not
  # fully launch.
  #
  wait $!
else
  # We are testing, not going to production.

  # See if 'replay' works.
  #
  "${BIN}" \
    --socket "$SOCKET" \
    server replay \
      --web-port "$port" \
      --log-level DEBUG \
      --database-dir "$DB_DIR" \
      --blocks-dir "$BLOCKS" \
      --staking-ledgers-dir "$LEDGERS" \
      --ledger-cadence 5000 \
      >> "$LOGS"/out \
      2>> "$LOGS"/err \
      &
  PID=$!
  wait_for_socket

  "${BIN}" --socket "$SOCKET" shutdown
  wait "$PID"
fi
