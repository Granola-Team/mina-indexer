#! /usr/bin/env bash

set -eux
set -o pipefail

# Ensure that we are within the source tree.
#
SRC="$(git rev-parse --show-toplevel)"

# Confirm that the binary is present and working.
#
BIN="$SRC"/result/bin/mina-indexer
"$BIN" --version

# Differentiate some files/directories using the Git revision.
#
REV="$(git rev-parse --short=8 HEAD)"

# This is the directory that we intend to configure for production use.
#
PROD="$HOME"/mina-indexer
mkdir -p "$PROD"
cd "$PROD"

# Ensure that the log directory exists.
#
LOGS=./logs/"$REV"
mkdir -p "$LOGS"

# Configure the './blocks' directory, downloading blocks from the
# granola-mina-blocks Linode bucket if need be. Note that the prior production
# instance may start to read these blocks, if it is running.
#
"$SRC"/ops/download-mina-blocks 5 ./blocks

# 4. Download the staking ledgers if needed.
#
"$SRC"/ops/download-staking-ledgers ./staking-ledgers

# Configure the socket.
#
SOCKET=./mina-indexer-"$REV".sock
wait_for_socket() {
    while true; do
        if [ -S "$SOCKET" ]; then
            return
        fi
        sleep 60
    done
}
ephemeral_port() {
    set +e
    LOW_BOUND=49152
    RANGE=16384
    while true; do
        CANDIDATE=$(( LOW_BOUND + (RANDOM % RANGE) ))
        if ! (echo "" >/dev/tcp/127.0.0.1/${CANDIDATE}) >/dev/null 2>&1; then
            echo $CANDIDATE
            break
        fi
    done
    set -e
}
port="$(ephemeral_port)"

# Construct the database. Ingest all blocks.
#
DB_DIR=./databases/"$REV"
"${BIN}" \
  --socket "$SOCKET" \
  server start \
    --web-port "$port" \
    --log-level DEBUG \
    --database-dir "$DB_DIR" \
    --blocks-dir ./blocks \
    --staking-ledgers-dir ./staking-ledgers \
    --ledger-cadence 5000 \
    > "$LOGS"/out \
    2> "$LOGS"/err \
    &
PID=$!
wait_for_socket
"${BIN}" --socket "$SOCKET" shutdown
wait "$PID"

# Terminate the prior production instance using the socket, if any. This will
# not work if we change the on-wire comms protocol for the shutdown command,
# note.
#
SOCKET=./mina-indexer.sock
if [ -e "$SOCKET" ]; then
    if "$BIN" --socket "$SOCKET" shutdown
    then
        :
    fi
    sleep 1  # Allow the prior indexer some time to remove the socket without
             # surprising it by removing it, ourselves.
fi
PID="$(pgrep mina-indexer)" || true
kill "$PID" || true
sleep 1
kill -9 "$PID" || true
sleep 1
rm -f "$SOCKET"

# We must daemonize. This requires forking a child in a new session. This is
# done with 'setsid'. The child must itself create a grandchild that is the
# mina-indexer. We use a shell invocation with a terminal '&' to fork that
# second time. Do not attempt to "simplify" this unless you really know what
# you are doing.
#
setsid \
  sh -c \
    '"$@" 0< /dev/null 1>> '"$LOGS"'/out 2>> '"$LOGS"'/err &' \
    -- \
    "$BIN" \
      --socket "$SOCKET" \
      server start \
        --log-level DEBUG \
        --web-hostname 0.0.0.0 \
        --database-dir "$DB_DIR" \
        --blocks-dir ./blocks \
        --staking-ledgers-dir ./staking-ledgers \
  &

# Wait for the above to return, otherwise the above fork'd process may not
# fully launch.
#
wait $!
