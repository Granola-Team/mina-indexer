schema {
  query: query
  mutation: mutation
  subscription: subscription
}

# Status for whenever the blockchain is reorganized
enum ChainReorganizationStatus {
  CHANGED
}

type subscription {
  # Event that triggers when the network sync status changes
  newSyncUpdate: SyncStatus!

  # Event that triggers when a new block is created that either contains a transaction with the specified public key, or was produced by it. If no public key is provided, then the event will trigger for every new block received
  newBlock(
    # Public key that is included in the block
    publicKey: PublicKey
  ): Block!

  # Event that triggers when the best tip changes in a way that is not a trivial extension of the existing one
  chainReorganization: ChainReorganizationStatus!
}

# A transaction encoded in the rosetta format
scalar RosettaTransaction

type SendRosettaTransactionPayload {
  # Command that was sent
  userCommand: UserCommand!
}

# Block encoded in extensional block format
scalar ExtensionalBlock

# Block encoded in precomputed block format
scalar PrecomputedBlock

type Applied {
  applied: Boolean!
}

# Network identifiers for another protocol participant
input NetworkPeer {
  libp2p_port: Int!

  # IP address of the remote host
  host: String!

  # base58-encoded peer ID
  peer_id: String!
}

input SetConnectionGatingConfigInput {
  # If true, no connections will be allowed unless they are from a trusted peer
  isolate: Boolean!

  # Peers we will never allow connections from (unless they are also trusted!)
  bannedPeers: [NetworkPeer!]!

  # Peers we will always allow connections from
  trustedPeers: [NetworkPeer!]!
}

input SetSnarkWorkFee {
  # Fee to get rewarded for producing snark work
  fee: UInt64!
}

type SetSnarkWorkFeePayload {
  # Returns the last fee set to do snark work
  lastFee: UInt64!
}

input SetSnarkWorkerInput {
  # Public key you wish to start snark-working on; null to stop doing any snark work
  publicKey: PublicKey
}

type SetSnarkWorkerPayload {
  # Returns the last public key that was designated for snark work
  lastSnarkWorker: PublicKey
}

input SetCoinbaseReceiverInput {
  # Public key of the account to receive coinbases. Block production keys will receive the coinbases if none is given
  publicKey: PublicKey
}

type SetCoinbaseReceiverPayload {
  # Returns the public key that was receiving coinbases previously, or none if it was the block producer
  lastCoinbaseReceiver: PublicKey

  # Returns the public key that will receive coinbase, or none if it will be the block producer
  currentCoinbaseReceiver: PublicKey
}

type TarFile {
  tarfile: String!
}

type ExportLogsPayload {
  # Tar archive containing logs
  exportLogs: TarFile!
}

input SendMintTokensInput {
  # Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  nonce: UInt32

  # Short arbitrary message provided by the sender
  memo: String

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32

  # Fee amount in order to mint tokens
  fee: UInt64!

  # Amount of token to create in the receiver's account
  amount: UInt64!

  # Public key to mint the new tokens for (defaults to token owner's account)
  receiver: PublicKey

  # Token to mint more of
  token: TokenId!

  # Public key of the token's owner
  tokenOwner: PublicKey!
}

type SendMintTokensPayload {
  # Token minting command that was sent
  mintTokens: UserCommandMintTokens!
}

input SendCreateTokenAccountInput {
  # Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  nonce: UInt32

  # Short arbitrary message provided by the sender
  memo: String

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32

  # Public key to pay the fees from and sign the transaction with (defaults to the receiver)
  feePayer: PublicKey

  # Fee amount in order to create a token account
  fee: UInt64!

  # Public key to create the account for
  receiver: PublicKey!

  # Token to create an account for
  token: TokenId!

  # Public key of the token's owner
  tokenOwner: PublicKey!
}

type SendCreateTokenAccountPayload {
  # Token account creation command that was sent
  createNewTokenAccount: UserCommandNewAccount!
}

input SendCreateTokenInput {
  # Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  nonce: UInt32

  # Short arbitrary message provided by the sender
  memo: String

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32

  # Fee amount in order to create a token
  fee: UInt64!

  # Public key to create the token for
  tokenOwner: PublicKey!

  # Public key to pay the fee from (defaults to the tokenOwner)
  feePayer: PublicKey
}

type SendCreateTokenPayload {
  # Token creation command that was sent
  createNewToken: UserCommandNewToken!
}

input SendDelegationInput {
  # Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  nonce: UInt32

  # Short arbitrary message provided by the sender
  memo: String

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32

  # Fee amount in order to send a stake delegation
  fee: UInt64!

  # Public key of the account being delegated to
  to: PublicKey!

  # Public key of sender of a stake delegation
  from: PublicKey!
}

type SendDelegationPayload {
  # Delegation change that was sent
  delegation: UserCommand!
}

# Base58Check-encoded private key
scalar PrivateKey

type SendPaymentPayload {
  # Payment that was sent
  payment: UserCommand!
}

type ImportAccountPayload {
  # The public key of the imported account
  publicKey: PublicKey!

  # True if the account had already been imported
  alreadyImported: Boolean!
  success: Boolean!
}

type ReloadAccountsPayload {
  # True when the reload was successful
  success: Boolean!
}

input DeleteAccountInput {
  # Public key of account to be deleted
  publicKey: PublicKey!
}

type DeleteAccountPayload {
  # Public key of the deleted account
  publicKey: PublicKey!
}

input LockInput {
  # Public key specifying which account to lock
  publicKey: PublicKey!
}

type LockPayload {
  # Public key of the locked account
  publicKey: PublicKey!

  # Details of locked account
  account: Account!
}

input UnlockInput {
  # Public key specifying which account to unlock
  publicKey: PublicKey!

  # Password for the account to be unlocked
  password: String!
}

type UnlockPayload {
  # Public key of the unlocked account
  publicKey: PublicKey! @deprecated(reason: "use account field instead")

  # Details of unlocked account
  account: Account!
}

input CreateHDAccountInput {
  # Index of the account in hardware wallet
  index: UInt32!
}

input AddAccountInput {
  # Password used to encrypt the new account
  password: String!
}

type AddAccountPayload {
  # Public key of the created account
  publicKey: PublicKey! @deprecated(reason: "use account field instead")

  # Details of created account
  account: Account!
}

type mutation {
  # Send a payment
  sendPayment(
    # If a signature is provided, this transaction is considered signed and will be broadcasted to the network without requiring a private key
    signature: SignatureInput
    input: SendPaymentInput!
  ): SendPaymentPayload!

  # Send a series of test payments
  sendTestPayments(
    # Delay with which a transaction shall be repeated
    repeat_delay_ms: UInt32!

    # How many times shall transaction be repeated
    repeat_count: UInt32!

    # The fee of each payment
    fee: UInt64!

    # The amount of each payment
    amount: UInt64!

    # The receiver of the payments
    receiver: PublicKey!

    # The private keys from which to sign the payments
    senders: [PrivateKey!]!
  ): Int!

  # Change your delegate by sending a transaction
  sendDelegation(
    # If a signature is provided, this transaction is considered signed and will be broadcasted to the network without requiring a private key
    signature: SignatureInput
    input: SendDelegationInput!
  ): SendDelegationPayload!

  # Create a new token
  createToken(
    # If a signature is provided, this transaction is considered signed and will be broadcasted to the network without requiring a private key
    signature: SignatureInput
    input: SendCreateTokenInput!
  ): SendCreateTokenPayload!

  # Create a new account for a token
  createTokenAccount(
    # If a signature is provided, this transaction is considered signed and will be broadcasted to the network without requiring a private key
    signature: SignatureInput
    input: SendCreateTokenAccountInput!
  ): SendCreateTokenAccountPayload!

  # Mint more of a token
  mintTokens(
    # If a signature is provided, this transaction is considered signed and will be broadcasted to the network without requiring a private key
    signature: SignatureInput
    input: SendMintTokensInput!
  ): SendMintTokensPayload!

  # Send a transaction in rosetta format
  sendRosettaTransaction(
    input: RosettaTransaction!
  ): SendRosettaTransactionPayload!
}

# Arbitrary JSON
scalar JSON

# The witness to a vrf evaluation
input VrfEvaluationInput {
  vrfThreshold: VrfThresholdInput
  scaledMessageHash: [String!]!
  s: String!
  c: String!
  publicKey: PublicKey!
  message: VrfMessageInput!
}

# The inputs to a vrf evaluation
input VrfMessageInput {
  # Position in the ledger of the delegator's account
  delegatorIndex: Int!

  # Formatted with base58check
  epochSeed: String!
  globalSlot: UInt32!
}

# The amount of stake delegated, used to determine the threshold for a vrf evaluation producing a block
input VrfThresholdInput {
  # The total amount of stake across all accounts in the epoch's staking ledger.
  totalStake: UInt64!

  # The amount of stake delegated to the vrf evaluator by the delegating account. This should match the amount in the epoch's staking ledger, which may be different to the amount in the current ledger.
  delegatedStake: UInt64!
}

# The amount of stake delegated, used to determine the threshold for a vrf evaluation winning a slot
type VrfThreshold {
  # The amount of stake delegated to the vrf evaluator by the delegating account. This should match the amount in the epoch's staking ledger, which may be different to the amount in the current ledger.
  delegatedStake: UInt64!

  # The total amount of stake across all accounts in the epoch's staking ledger.
  totalStake: UInt64!
}

# Base58Check-encoded epoch seed
scalar EpochSeed

# The inputs to a vrf evaluation
type VrfMessage {
  globalSlot: UInt32!
  epochSeed: EpochSeed!

  # Position in the ledger of the delegator's account
  delegatorIndex: Int!
}

# A witness to a vrf evaluation, which may be externally verified
type VrfEvaluation {
  message: VrfMessage!
  publicKey: PublicKey!
  c: String!
  s: String!

  # A group element represented as 2 field elements
  scaledMessageHash: [String!]!
  vrfThreshold: VrfThreshold

  # The vrf output derived from the evaluation witness. If null, the vrf witness was invalid.
  vrfOutput: String

  # The vrf output derived from the evaluation witness, as a fraction. This represents a won slot if vrfOutputFractional <= (1 - (1 / 4)^(delegated_balance / total_stake)). If null, the vrf witness was invalid.
  vrfOutputFractional: Float

  # Whether the threshold to produce a block was met, if specified
  thresholdMet(
    # Override for delegation threshold
    input: VrfThresholdInput
  ): Boolean
}

# A cryptographic signature -- you must provide either field+scalar or rawSignature
input SignatureInput {
  # Raw encoded signature
  rawSignature: String

  # Scalar component of signature
  scalar: String

  # Field component of signature
  field: String
}

input SendPaymentInput {
  # Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  nonce: UInt32

  # Short arbitrary message provided by the sender
  memo: String

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32

  # Fee amount in order to send payment
  fee: UInt64!

  # Amount of mina to send to receiver
  amount: UInt64!

  # Token to send
  token: TokenId

  # Public key of recipient of payment
  to: PublicKey!

  # Public key of sender of payment
  from: PublicKey!
}

type GenesisConstants {
  # The fee charged to create a new account
  accountCreationFee: UInt64!

  # The amount received as a coinbase reward for producing a block
  coinbase: UInt64!
}

enum sign {
  PLUS
  MINUS
}

# Signed fee
type SignedFee {
  # +/-
  sign: sign!

  # Fee
  feeMagnitude: UInt64!
}

# Transition from a source ledger to a target ledger with some fee excess and increase in supply
type WorkDescription {
  # Base58Check-encoded hash of the source ledger
  sourceLedgerHash: String!

  # Base58Check-encoded hash of the target ledger
  targetLedgerHash: String!

  # Total transaction fee that is not accounted for in the transition from source ledger to target ledger
  feeExcess: SignedFee!

  # Increase in total coinbase reward
  supplyIncrease: UInt64!

  # Unique identifier for a snark work
  workId: Int!
}

# Snark work bundles that are not available in the pool yet
type PendingSnarkWork {
  # Work bundle with one or two snark work
  workBundle: [WorkDescription!]!
}

type TrustStatusPayload {
  # IP address
  ip_addr: String!

  # libp2p Peer ID
  peer_id: String!

  # Trust score
  trust: Float!

  # Banned status
  banned_status: String
}

# Status of a transaction
enum TransactionStatus {
  # A transaction that is on the longest chain
  INCLUDED

  # A transaction either in the transition frontier or in transaction pool but is not on the longest chain
  PENDING

  # The transaction has either been snarked, reached finality through consensus or has been dropped
  UNKNOWN
}

# Completed snark works
type CompletedWork {
  # Public key of the prover
  prover: PublicKey!

  # Amount the prover is paid for the snark work
  fee: UInt64!

  # Unique identifier for the snark work purchased
  workIds: [Int!]!
}

type FeeTransfer {
  # Public key of fee transfer recipient
  recipient: PublicKey!

  # Amount that the recipient is paid in this fee transfer
  fee: UInt64!

  # Fee_transfer|Fee_transfer_via_coinbase Snark worker fees deducted from the coinbase amount are of type 'Fee_transfer_via_coinbase', rest are deducted from transaction fees
  type: String!
}

type UserCommandPayment implements UserCommand {
  id: ID!
  hash: String!

  # String describing the kind of user command
  kind: UserCommandKind!

  # Sequence number of command for the fee-payer's account
  nonce: Int!

  # Account that the command is sent from
  source: Account!

  # Account that the command applies to
  receiver: Account!

  # Account that pays the fees for the command
  feePayer: Account!

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32!

  # Token used for the transaction
  token: TokenId!

  # Amount that the source is sending to receiver; 0 for commands without an associated amount
  amount: UInt64!

  # Token used to pay the fee
  feeToken: TokenId!

  # Fee that the fee-payer is willing to pay for making the transaction
  fee: UInt64!

  # A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  memo: String!

  # If true, this command represents a delegation of stake
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  # Public key of the sender
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  # Account of the sender
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  # Public key of the receiver
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  # Account of the receiver
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  # null is no failure or status unknown, reason for failure otherwise.
  failureReason: String
}

type UserCommandDelegation implements UserCommand {
  delegator: Account!
  delegatee: Account!
  id: ID!
  hash: String!

  # String describing the kind of user command
  kind: UserCommandKind!

  # Sequence number of command for the fee-payer's account
  nonce: Int!

  # Account that the command is sent from
  source: Account!

  # Account that the command applies to
  receiver: Account!

  # Account that pays the fees for the command
  feePayer: Account!

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32!

  # Token used for the transaction
  token: TokenId!

  # Amount that the source is sending to receiver; 0 for commands without an associated amount
  amount: UInt64!

  # Token used to pay the fee
  feeToken: TokenId!

  # Fee that the fee-payer is willing to pay for making the transaction
  fee: UInt64!

  # A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  memo: String!

  # If true, this command represents a delegation of stake
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  # Public key of the sender
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  # Account of the sender
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  # Public key of the receiver
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  # Account of the receiver
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  # null is no failure or status unknown, reason for failure otherwise.
  failureReason: String
}

type UserCommandNewToken implements UserCommand {
  # Public key to set as the owner of the new token
  tokenOwner: PublicKey!

  # Whether new accounts created in this token are disabled
  newAccountsDisabled: Boolean!
  id: ID!
  hash: String!

  # String describing the kind of user command
  kind: UserCommandKind!

  # Sequence number of command for the fee-payer's account
  nonce: Int!

  # Account that the command is sent from
  source: Account!

  # Account that the command applies to
  receiver: Account!

  # Account that pays the fees for the command
  feePayer: Account!

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32!

  # Token used for the transaction
  token: TokenId!

  # Amount that the source is sending to receiver; 0 for commands without an associated amount
  amount: UInt64!

  # Token used to pay the fee
  feeToken: TokenId!

  # Fee that the fee-payer is willing to pay for making the transaction
  fee: UInt64!

  # A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  memo: String!

  # If true, this command represents a delegation of stake
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  # Public key of the sender
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  # Account of the sender
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  # Public key of the receiver
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  # Account of the receiver
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  # null is no failure or status unknown, reason for failure otherwise.
  failureReason: String
}

type UserCommandNewAccount implements UserCommand {
  # The account that owns the token for the new account
  tokenOwner: Account!

  # Whether this account should be disabled upon creation. If this command was not issued by the token owner, it should match the 'newAccountsDisabled' property set in the token owner's account.
  disabled: Boolean!
  id: ID!
  hash: String!

  # String describing the kind of user command
  kind: UserCommandKind!

  # Sequence number of command for the fee-payer's account
  nonce: Int!

  # Account that the command is sent from
  source: Account!

  # Account that the command applies to
  receiver: Account!

  # Account that pays the fees for the command
  feePayer: Account!

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32!

  # Token used for the transaction
  token: TokenId!

  # Amount that the source is sending to receiver; 0 for commands without an associated amount
  amount: UInt64!

  # Token used to pay the fee
  feeToken: TokenId!

  # Fee that the fee-payer is willing to pay for making the transaction
  fee: UInt64!

  # A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  memo: String!

  # If true, this command represents a delegation of stake
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  # Public key of the sender
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  # Account of the sender
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  # Public key of the receiver
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  # Account of the receiver
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  # null is no failure or status unknown, reason for failure otherwise.
  failureReason: String
}

# The kind of user command
scalar UserCommandKind

type UserCommandMintTokens implements UserCommand {
  # The account that owns the token to mint
  tokenOwner: Account!
  id: ID!
  hash: String!

  # String describing the kind of user command
  kind: UserCommandKind!

  # Sequence number of command for the fee-payer's account
  nonce: Int!

  # Account that the command is sent from
  source: Account!

  # Account that the command applies to
  receiver: Account!

  # Account that pays the fees for the command
  feePayer: Account!

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32!

  # Token used for the transaction
  token: TokenId!

  # Amount that the source is sending to receiver; 0 for commands without an associated amount
  amount: UInt64!

  # Token used to pay the fee
  feeToken: TokenId!

  # Fee that the fee-payer is willing to pay for making the transaction
  fee: UInt64!

  # A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  memo: String!

  # If true, this command represents a delegation of stake
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  # Public key of the sender
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  # Account of the sender
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  # Public key of the receiver
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  # Account of the receiver
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  # null is no failure or status unknown, reason for failure otherwise.
  failureReason: String
}

# Common interface for user commands
interface UserCommand {
  id: ID!
  hash: String!

  # String describing the kind of user command
  kind: UserCommandKind!

  # Sequence number of command for the fee-payer's account
  nonce: Int!

  # Account that the command is sent from
  source: Account!

  # Account that the command applies to
  receiver: Account!

  # Account that pays the fees for the command
  feePayer: Account!

  # The global slot number after which this transaction cannot be applied
  validUntil: UInt32!

  # Token used by the command
  token: TokenId!

  # Amount that the source is sending to receiver - 0 for commands that are not associated with an amount
  amount: UInt64!

  # Token used to pay the fee
  feeToken: TokenId!

  # Fee that the fee-payer is willing to pay for making the transaction
  fee: UInt64!

  # Short arbitrary message provided by the sender
  memo: String!

  # If true, this represents a delegation of stake, otherwise it is a payment
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  # Public key of the sender
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  # Account of the sender
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  # Public key of the receiver
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  # Account of the receiver
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  # null is no failure, reason for failure otherwise.
  failureReason: String
}

# Different types of transactions in a block
type Transactions {
  # List of user commands (payments and stake delegations) included in this block
  userCommands: [UserCommand!]!

  # List of fee transfers included in this block
  feeTransfer: [FeeTransfer!]!

  # Amount of mina granted to the producer of this block
  coinbase: UInt64!

  # Account to which the coinbase for this block was granted
  coinbaseReceiverAccount: Account
}

type protocolStateProof {
  # Base-64 encoded proof
  base64: String
}

type NextEpochData {
  ledger: epochLedger!
  seed: String!
  startCheckpoint: String!
  lockCheckpoint: String!
  epochLength: UInt32!
}

type epochLedger {
  hash: String!
  totalCurrency: UInt64!
}

type StakingEpochData {
  ledger: epochLedger!
  seed: String!
  startCheckpoint: String!
  lockCheckpoint: String!
  epochLength: UInt32!
}

type ConsensusState {
  # Length of the blockchain at this block
  blockchainLength: UInt32! @deprecated(reason: "use blockHeight instead")

  # Height of the blockchain at this block
  blockHeight: UInt32!
  epochCount: UInt32!
  minWindowDensity: UInt32!
  lastVrfOutput: String!

  # Total currency in circulation at this block
  totalCurrency: UInt64!
  stakingEpochData: StakingEpochData!
  nextEpochData: NextEpochData!
  hasAncestorInSameCheckpointWindow: Boolean!

  # Slot in which this block was created
  slot: UInt32!

  # Slot since genesis (across all hard-forks)
  slotSinceGenesis: UInt32!

  # Epoch in which this block was created
  epoch: UInt32!
}

type BlockchainState {
  # date (stringified Unix time - number of milliseconds since January 1, 1970)
  date: String!

  # utcDate (stringified Unix time - number of milliseconds since January 1, 1970). Time offsets are adjusted to reflect true wall-clock time instead of genesis time.
  utcDate: String!

  # Base58Check-encoded hash of the snarked ledger
  snarkedLedgerHash: String!

  # Base58Check-encoded hash of the staged ledger
  stagedLedgerHash: String!

  # Block finished a staged ledger, and a proof was emitted from it and included into this block's proof. If there is no transition frontier available or no block found, this will return null.
  stagedLedgerProofEmitted: Boolean
}

type ProtocolState {
  # Base58Check-encoded hash of the previous state
  previousStateHash: String!

  # State which is agnostic of a particular consensus algorithm
  blockchainState: BlockchainState!

  # State specific to the Codaboros Proof of Stake consensus algorithm
  consensusState: ConsensusState!
}

type Block {
  # Public key of account that produced this block
  creator: PublicKey! @deprecated(reason: "use creatorAccount field instead")

  # Account that produced this block
  creatorAccount: Account!

  # Account that won the slot (Delegator/Staker)
  winnerAccount: Account!

  # Base58Check-encoded hash of the state after this block
  stateHash: String!

  # Experimental: Bigint field-element representation of stateHash
  stateHashField: String!
  protocolState: ProtocolState!

  # Snark proof of blockchain state
  protocolStateProof: protocolStateProof!
  transactions: Transactions!

  # Count of user command transactions in the block
  commandTransactionCount: Int!
  snarkJobs: [CompletedWork!]!
}

type SnarkWorker {
  # Public key of current snark worker
  key: PublicKey! @deprecated(reason: "use account field instead")

  # Account of the current snark worker
  account: Account!

  # Fee that snark worker is charging to generate a snark proof
  fee: UInt64!
}

type NetworkPeerPayload {
  # base58-encoded peer ID
  peer_id: String!

  # IP address of the remote host
  host: String!
  libp2p_port: Int!
}

type SetConnectionGatingConfigPayload {
  # Peers we will always allow connections from
  trustedPeers: [NetworkPeerPayload!]!

  # Peers we will never allow connections from (unless they are also trusted!)
  bannedPeers: [NetworkPeerPayload!]!

  # If true, no connections will be allowed unless they are from a trusted peer
  isolate: Boolean!
}

# A total balance annotated with the amount that is currently unknown with the invariant unknown <= total, as well as the currently liquid and locked balances.
type AnnotatedBalance {
  # The amount of mina owned by the account
  total: UInt64!

  # The amount of mina owned by the account whose origin is currently unknown
  unknown: UInt64!

  # The amount of mina owned by the account which is currently available. Can be null if bootstrapping.
  liquid: UInt64

  # The amount of mina owned by the account which is currently locked. Can be null if bootstrapping.
  locked: UInt64

  # Block height at which balance was measured
  blockHeight: UInt32!

  # Hash of block at which balance was measured. Can be null if bootstrapping. Guaranteed to be non-null for direct account lookup queries when not bootstrapping. Can also be null when accessed as nested properties (eg. via delegators).
  stateHash: String
}

# String representing a uint64 number in base 10
scalar UInt64

type AccountTiming {
  # The initial minimum balance for a time-locked account
  initial_mininum_balance: UInt64

  # The cliff time for a time-locked account
  cliff_time: UInt32

  # The cliff amount for a time-locked account
  cliff_amount: UInt64

  # The vesting period for a time-locked account
  vesting_period: UInt32

  # The vesting increment for a time-locked account
  vesting_increment: UInt64
}

# String representation of a token's UInt64 identifier
scalar TokenId

# Base58Check-encoded public key string
scalar PublicKey

# An account record according to the daemon
type Account {
  # The public identity of the account
  publicKey: PublicKey!

  # The token associated with this account
  token: TokenId!

  # The timing associated with this account
  timing: AccountTiming!

  # The amount of mina owned by the account
  balance: AnnotatedBalance!

  # A natural number that increases with each transaction (stringified uint32)
  nonce: String

  # Like the `nonce` field, except it includes the scheduled transactions (transactions not yet included in a block) (stringified uint32)
  inferredNonce: String

  # The account that you delegated on the staking ledger of the current block's epoch
  epochDelegateAccount: Account

  # Top hash of the receipt chain merkle-list
  receiptChainHash: String

  # The public key to which you are delegating - if you are not delegating to anybody, this would return your public key
  delegate: PublicKey @deprecated(reason: "use delegateAccount instead")

  # The account to which you are delegating - if you are not delegating to anybody, this would return your public key
  delegateAccount: Account

  # The list of accounts which are delegating to you (note that the info is recorded in the last epoch so it might not be up to date with the current account status)
  delegators: [Account!]

  # The list of accounts which are delegating to you in the last epoch (note that the info is recorded in the one before last epoch epoch so it might not be up to date with the current account status)
  lastEpochDelegators: [Account!]

  # The previous epoch lock hash of the chain which you are voting for
  votingFor: String

  # True if you are actively staking with this account on the current daemon - this may not yet have been updated if the staking key was changed recently
  stakingActive: Boolean!

  # Path of the private key file for this account
  privateKeyPath: String!

  # True if locked, false if unlocked, null if the account isn't tracked by the queried daemon
  locked: Boolean

  # True if this account owns its associated token
  isTokenOwner: Boolean

  # True if this account has been disabled by the owner of the associated token
  isDisabled: Boolean

  # The index of this account in the ledger, or null if this account does not yet have a known position in the best tip ledger
  index: Int
}

type Metrics {
  blockProductionDelay: [Int!]!
  transactionPoolDiffReceived: Int!
  transactionPoolDiffBroadcasted: Int!
  transactionsAddedToPool: Int!
  transactionPoolSize: Int!
}

type AddrsAndPorts {
  externalIp: String!
  bindIp: String!
  peer: Peer
  libp2pPort: Int!
  clientPort: Int!
}

type ConsensusConfiguration {
  delta: Int!
  k: Int!
  slotsPerEpoch: Int!
  slotDuration: Int!
  epochDuration: Int!
  genesisStateTimestamp: String!
  acceptableNetworkDelay: Int!
}

# Consensus time and the corresponding global slot since genesis
type ConsensusTimeGlobalSlot {
  # Time in terms of slot number in an epoch, start and end time of the slot since UTC epoch
  consensusTime: ConsensusTime!
  globalSlotSinceGenesis: UInt32!
}

type BlockProducerTimings {
  # Next block production time
  times: [ConsensusTime!]!

  # Next block production global-slot-since-genesis
  globalSlotSinceGenesis: [UInt32!]!

  # Consensus time of the block that was used to determine the next block production time
  generatedFromConsensusAt: ConsensusTimeGlobalSlot!
}

# String representing a uint32 number in base 10
scalar UInt32

type ConsensusTime {
  epoch: UInt32!
  slot: UInt32!
  globalSlot: UInt32!
  startTime: String!
  endTime: String!
}

type Interval {
  start: String!
  stop: String!
}

type Histogram {
  values: [Int!]!
  intervals: [Interval!]!
  underflow: Int!
  overflow: Int!
}

type RpcPair {
  dispatch: Histogram
  impl: Histogram
}

type RpcTimings {
  getStagedLedgerAux: RpcPair!
  answerSyncLedgerQuery: RpcPair!
  getAncestry: RpcPair!
  getTransitionChainProof: RpcPair!
  getTransitionChain: RpcPair!
}

type Histograms {
  rpcTimings: RpcTimings!
  externalTransitionLatency: Histogram
  acceptedTransitionLocalLatency: Histogram
  acceptedTransitionRemoteLatency: Histogram
  snarkWorkerTransitionTime: Histogram
  snarkWorkerMergeTime: Histogram
}

type Peer {
  host: String!
  libp2pPort: Int!
  peerId: String!
}

type DaemonStatus {
  numAccounts: Int
  blockchainLength: Int
  highestBlockLengthReceived: Int!
  highestUnvalidatedBlockLengthReceived: Int!
  uptimeSecs: Int!
  ledgerMerkleRoot: String
  stateHash: String
  chainId: String!
  commitId: String!
  confDir: String!
  peers: [Peer!]!
  userCommandsSent: Int!
  snarkWorker: String
  snarkWorkFee: Int!
  syncStatus: SyncStatus!
  catchupStatus: [String!]
  blockProductionKeys: [String!]!
  coinbaseReceiver: String
  histograms: Histograms
  consensusTimeBestTip: ConsensusTime
  globalSlotSinceGenesisBestTip: Int
  nextBlockProduction: BlockProducerTimings
  consensusTimeNow: ConsensusTime!
  consensusMechanism: String!
  consensusConfiguration: ConsensusConfiguration!
  addrsAndPorts: AddrsAndPorts!
  metrics: Metrics!
}

# Sync status of daemon
enum SyncStatus {
  CONNECTING
  LISTENING
  OFFLINE
  BOOTSTRAP
  SYNCED
  CATCHUP
}

type query {
  # Network sync status
  syncStatus: SyncStatus!

  # Get running daemon status
  daemonStatus: DaemonStatus!

  # The version of the node (git commit hash)
  version: String

  # The rules that the libp2p helper will use to determine which connections to permit
  connectionGatingConfig: SetConnectionGatingConfigPayload!

  # Find any account via a public key and token
  account(
    # Token of account being retrieved (defaults to CODA)
    token: TokenId

    # Public key of account being retrieved
    publicKey: PublicKey!
  ): Account

  # Find all accounts for a public key
  accounts(
    # Public key to find accounts for
    publicKey: PublicKey!
  ): [Account!]!

  # Find the public key that owns a given token
  tokenOwner(
    # Token to find the owner for
    token: TokenId!
  ): PublicKey

  # Retrieve a list of blocks from transition frontier's root to the current best tip. Returns an error if the system is bootstrapping.
  bestChain(
    # The maximum number of blocks to return. If there are more blocks in the transition frontier from root to tip, the n blocks closest to the best tip will be returned
    maxLength: Int
  ): [Block!]

  # Retrieve a block with the given state hash or height, if contained in the transition frontier.
  block(
    # The height of the desired block in the best chain
    height: Int

    # The state hash of the desired block
    stateHash: String
  ): Block!

  # Get the genesis block
  genesisBlock: Block!

  # List of peers that the daemon first used to connect to the network
  initialPeers: [String!]!

  # List of peers that the daemon is currently connected to
  getPeers: [Peer!]!

  # Retrieve all the scheduled user commands for a specified sender that the current daemon sees in their transaction pool. All scheduled commands are queried if no sender is specified
  pooledUserCommands(
    # Ids of UserCommands
    ids: [ID!]

    # Hashes of the commands to find in the pool
    hashes: [String!]

    # Public key of sender of pooled user commands
    publicKey: PublicKey
  ): [UserCommand!]!

  # Get the status of a transaction
  transactionStatus(
    # Id of a UserCommand
    payment: ID!
  ): TransactionStatus!

  # Trust status for an IPv4 or IPv6 address
  trustStatus(ipAddress: String!): [TrustStatusPayload!]

  # IP address and trust status for all peers
  trustStatusAll: [TrustStatusPayload!]!

  # List of completed snark works that have the lowest fee so far
  snarkPool: [CompletedWork!]!

  # List of snark works that are yet to be done
  pendingSnarkWork: [PendingSnarkWork!]!

  # The constants used to determine the configuration of the genesis block and all of its transitive dependencies
  genesisConstants: GenesisConstants!

  # The time offset in seconds used to convert real times into blockchain times
  timeOffset: Int!

  # The next token ID that has not been allocated. Token IDs are allocated sequentially, so all lower token IDs have been allocated
  nextAvailableToken: TokenId!

  # Validate the format and signature of a payment
  validatePayment(
    # If a signature is provided, this transaction is considered signed and will be broadcasted to the network without requiring a private key
    signature: SignatureInput
    input: SendPaymentInput!
  ): Boolean!

  # Evaluate a vrf for the given public key. This includes a witness which may be verified without access to the private key for this vrf evaluation.
  evaluateVrf(
    vrfThreshold: VrfThresholdInput
    publicKey: PublicKey!
    message: VrfMessageInput!
  ): VrfEvaluation!

  # Check a vrf evaluation commitment. This can be used to check vrf evaluations without needing to reveal the private key, in the format returned by evaluateVrf
  checkVrf(input: VrfEvaluationInput!): VrfEvaluation!

  # The runtime configuration passed to the daemon at start-up
  runtimeConfig: JSON!

  # A graphviz dot format representation of the deamon's internal thread graph
  threadGraph: String!
}
