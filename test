#!/usr/bin/env bash
set -ex

# Collect the binaries under test and the test ledger.
IDXR="$(pwd)"/target/release/mina-indexer
LEDGER="$(pwd)"/tests/data/genesis_ledgers/mainnet.json
BLOCKS_FETCHER="$(pwd)"/download_blocks

# JSON Schemas
SUMMARY_SCHEMA="$(pwd)"/tests/json-schemas/summary.json

# The rest of this script's logic assumes that the testing is done from within
# this temporary directory.
TEST_DIR="$(mktemp -d 2>/dev/null || mktemp -d -t 'mytmpdir')"
cd "$TEST_DIR"

# Invoke this function when exiting this script for any reason.
test_cleanup() {
    err=$?
    if [ $err != 0 ]; then
        echo "\e[0;31mTest failed ($test): $err\e[0;37m"
        teardown
        exit 1
    fi
    rm -rf "${TEST_DIR}"
}

trap test_cleanup EXIT

ephemeral_port() {
    set +e
    LOW_BOUND=49152
    RANGE=16384
    while true; do
        CANDIDATE=$[$LOW_BOUND + ($RANDOM % $RANGE)]
        (echo "" >/dev/tcp/127.0.0.1/${CANDIDATE}) >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo $CANDIDATE
            break
        fi
    done
    set -e
}

idxr() {
    RUST_BACKTRACE=full "$IDXR" "$@"
}

idxr_server() {
    RUST_BACKTRACE=full "$IDXR" server "$@" &
    echo $! > idxr_pid
}

idxr_server_start() {
    idxr_server start "$@"
}

dl_mainnet() {
    "$BLOCKS_FETCHER" mina_network_block_data 2 "$1" mainnet "$2"
}

dl_mainnet_single() {
    "$BLOCKS_FETCHER" mina_network_block_data "$1" "$1" mainnet "$2"
}

dl_mainnet_range() {
    "$BLOCKS_FETCHER" mina_network_block_data "$1" "$2" mainnet "$3"
}

assert() {
    expected="$1"
    actual="$2"

    if [ "$expected" != "$actual" ]; then
        echo "\e[0;31mTest Failed: Expected $expected, but got $actual\e[0;37m"
        exit 1
    else
        echo "Test Passed!"
    fi
}

assert_directory_exists() {
    directory="$1"

    if [ ! -d "$directory" ]; then
        echo "Test Failed: Expected directory $directory to exist, but it does not."
        exit 1
    else
        echo "Test Passed: Directory $directory exists."
    fi
}

setup() {
    echo "setup"
    mkdir blocks
    mkdir database
    mkdir logs
}

teardown() {
    kill "$(cat idxr_pid)" 2>/dev/null || true
    rm -f ./idxr_pid
    rm -rf ./blocks
    rm -rf ./database
    rm -rf ./logs
    rm -f ./mina-indexer.sock
}

test_indexer_cli_reports() {
    test=test_indexer_cli_reports

    # Indexer reports usage with no arguments
    idxr 2>&1 |
        grep -iq "Usage:"

    # Indexer reports usage for server subcommand
    idxr_server 2>&1 |
        grep -iq "Usage: mina-indexer server"

    # Indexer server cli subcommand works with default args
    idxr_server --help 2>/dev/null

    # Indexer reports usage for client subcommands
    idxr account --help 2>&1 |
        grep -iq "Usage: mina-indexer account"

    idxr block --help 2>&1 |
        grep -iq "Usage: mina-indexer block"

    idxr best-tip --help 2>&1 |
        grep -iq "Usage: mina-indexer best-tip"

    idxr blocks-at-height --help 2>&1 |
        grep -iq "Usage: mina-indexer blocks-at-height"

    idxr blocks-at-slot --help 2>&1 |
        grep -iq "Usage: mina-indexer blocks-at-slot"

    idxr blocks-at-public-key --help 2>&1 |
        grep -iq "Usage: mina-indexer blocks-at-public-key"

    idxr checkpoint --help 2>&1 |
        grep -iq "Usage: mina-indexer checkpoint"

    idxr best-ledger --help 2>&1 |
        grep -iq "Usage: mina-indexer best-ledger"

    idxr ledger --help 2>&1 |
        grep -iq "Usage: mina-indexer ledger"

    idxr ledger-at-height --help 2>&1 |
        grep -iq "Usage: mina-indexer ledger-at-height"

    idxr shutdown --help 2>&1 |
        grep -iq "Usage: mina-indexer shutdown"

    idxr summary --help 2>&1 |
        grep -iq "Usage: mina-indexer summary"

    idxr tx-hash --help 2>&1 |
        grep -iq "Usage: mina-indexer tx-hash"

    idxr tx-public-key --help 2>&1 |
        grep -iq "Usage: mina-indexer tx-public-key"

    idxr tx-state-hash --help 2>&1 |
        grep -iq "Usage: mina-indexer tx-state-hash"
}

# Indexer server starts up without any precomputed blocks
test_server_startup() {
    test=test_server_startup
    
    setup
    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    result=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    assert '3NKeMoncuHab5ScarV5ViyF16cJPT4taWNSaTLS64Dp67wuXigPZ' $result

    teardown
}

# Indexer server ipc is available during initialization
test_ipc_is_available_immediately() {
    test=test_ipc_is_available_immediately

    setup
    dl_mainnet 100 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --genesis-ledger "$LEDGER" \
        --genesis-hash 3NKeMoncuHab5ScarV5ViyF16cJPT4taWNSaTLS64Dp67wuXigPZ
    sleep 1

    idxr summary
    teardown
}

# Indexer server starts and creates directories with minimal args
test_startup_dirs_get_created() {
    test=test_startup_dirs_get_created

    setup
    idxr_server_start \
        --startup-dir ./startup-blocks \
        --watch-dir ./watch-blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 1

    assert_directory_exists "./startup-blocks"
    assert_directory_exists "./watch-blocks"
    assert_directory_exists "./database"
    assert_directory_exists "./logs"

    # check for server args
    if [ ! -f "./config.json" ]; then
        echo "Test Failed: Expected ./config.json to exist, but it does not."
        exit 1
    else
        echo "Test Passed: ./config.json exists."
    fi

    teardown
}

# Indexer server reports correct balance for Genesis Ledger Account
test_account_balance_cli() {
    test=test_account_balance_cli

    setup
    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    result=$(idxr account --public-key B62qqDJCQsfDoHJvJCh1hgTpiVbmgBg8SbNKLMXsjuVsX5pxCELDyFk | jq -r .balance)
    assert '148837200000000' $result

    teardown
}

# Indexer server returns the correct account
test_account_public_key_json() {
    test=test_account_public_key_json

    setup
    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    result=$(idxr account -k B62qqDJCQsfDoHJvJCh1hgTpiVbmgBg8SbNKLMXsjuVsX5pxCELDyFk | jq -r .public_key)
    assert 'B62qqDJCQsfDoHJvJCh1hgTpiVbmgBg8SbNKLMXsjuVsX5pxCELDyFk' $result

    teardown
}

# Indexer summary returns the correct canonical tip
test_canonical_tip() {
    test=test_canonical_tip

    setup
    dl_mainnet 15 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5
    
    hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)
    
    assert 5 $length
    assert '3NKQUoBfi9vkbuqtDJmSEYBQrcSo4GjwG8bPCiii4yqM8AxEQvtY' $hash

    teardown
}

# Indexer server handles canonical threshold correctly
test_canonical_threshold() {
    test=test_canonical_threshold

    num_seq_blocks=15
    canonical_threshold=2

    setup
    dl_mainnet $num_seq_blocks ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --canonical-threshold $canonical_threshold
    sleep 5

    hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert $(expr $num_seq_blocks - $canonical_threshold) $length
    assert '3NKXzc1hAE1bK9BSkJUhBBSznMhwW3ZxUTgdoLoqzW6SvqVFcAw5' $hash

    teardown
}

# Indexer server returns the correct best tip
test_best_tip() {
    test=test_best_tip

    setup
    dl_mainnet 15 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # best tip query
    hash=$(idxr best-tip | jq -r .state_hash)
    canonicity=$(idxr best-tip | jq -r .canonicity)
    length=$(idxr best-tip | jq -r .blockchain_length)
    canonicity_v=$(idxr best-tip -v | jq -r .canonicity)

    # witness tree summary
    wt_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    wt_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    
    assert $wt_hash $hash
    assert $wt_length $length
    assert 'Canonical' $canonicity
    assert 'Canonical' $canonicity_v

    teardown
}

# Indexer server returns the correct blocks for height and slot queries
test_blocks() {
    test=test_blocks

    setup
    dl_mainnet 10 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # basic height query
    hash=$(idxr blocks-at-height -h 10 | jq -r .[0].state_hash)
    slot=$(idxr blocks-at-height -h 10 | jq -r .[0].global_slot_since_genesis)
    length=$(idxr blocks-at-height -h 10 | jq -r .[0].blockchain_length)
    canonicity=$(idxr blocks-at-height -h 10 | jq -r .[0].canonicity)

    # verbose height query
    hash_v=$(idxr blocks-at-height -h 10 -v | jq -r .[0].state_hash)
    length_v=$(idxr blocks-at-height -h 10 -v | jq -r .[0].blockchain_length)
    canonicity_v=$(idxr blocks-at-height -h 10 -v | jq -r .[0].canonicity)

    # witness tree summary
    wt_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    wt_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    
    assert 9 $slot
    assert $wt_hash $hash
    assert $wt_hash $hash_v
    assert $wt_length $length
    assert $wt_length $length_v
    assert 'Canonical' $canonicity
    assert 'Canonical' $canonicity_v

    # basic slot query
    hash=$(idxr blocks-at-slot -s 9 | jq -r .[0].state_hash)
    slot=$(idxr blocks-at-slot -s 9 | jq -r .[0].global_slot_since_genesis)
    length=$(idxr blocks-at-slot -s 9 | jq -r .[0].blockchain_length)
    canonicity=$(idxr blocks-at-slot -s 9 | jq -r .[0].canonicity)

    # verbose slot query
    hash_v=$(idxr blocks-at-slot -s 9 -v | jq -r .[0].state_hash)
    length_v=$(idxr blocks-at-slot -s 9 -v | jq -r .[0].blockchain_length)
    canonicity_v=$(idxr blocks-at-slot -s 9 -v | jq -r .[0].canonicity)
    
    assert 9 $slot
    assert $wt_hash $hash
    assert $wt_hash $hash_v
    assert $wt_length $length
    assert $wt_length $length_v
    assert 'Canonical' $canonicity
    assert 'Canonical' $canonicity_v

    # basic public key query
    hash=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 | jq -r .[0].state_hash)
    slot=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 | jq -r .[0].global_slot_since_genesis)
    length=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 | jq -r .[0].blockchain_length)
    canonicity=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 | jq -r .[0].canonicity)

    # verbose public key query
    hash_v=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 -v | jq -r .[0].state_hash)
    length_v=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 -v | jq -r .[0].blockchain_length)
    canonicity_v=$(idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 -v | jq -r .[0].canonicity)
    
    assert 9 $slot
    assert $wt_hash $hash
    assert $wt_hash $hash_v
    assert $wt_length $length
    assert $wt_length $length_v
    assert 'Canonical' $canonicity
    assert 'Canonical' $canonicity_v

    # height 10 = slot 9
    slot=$(idxr blocks-at-slot -s 9 | jq -r .)
    height=$(idxr blocks-at-height -h 10 | jq -r .)
    assert "$slot" "$height"

    # write at height to file
    file=./blocks_at_height.json
    idxr blocks-at-height -h 10 -p $file
    
    height=$(cat $file | jq -r .[0].blockchain_length)
    slot=$(cat $file | jq -r .[0].global_slot_since_genesis)
    
    assert 9 $slot
    assert 10 $height

    # write at slot to file
    file=./blocks_at_slot.json
    idxr blocks-at-slot -s 9 -p $file

    height=$(cat $file | jq -r .[0].blockchain_length)
    slot=$(cat $file | jq -r .[0].global_slot_since_genesis)
    
    assert 9 $slot
    assert 10 $height

    # write at public key to file
    file=./blocks_at_pk.json
    idxr blocks-at-public-key -k B62qpbZkvpHZ1a5nsTbANuRtrdw4YraTyA4nvJDm6HpP1YMC9QStxX3 -p $file

    height=$(cat $file | jq -r .[0].blockchain_length)
    slot=$(cat $file | jq -r .[0].global_slot_since_genesis)
    
    assert 9 $slot
    assert 10 $height

    teardown
}

# Indexer handles copied blocks correctly
test_block_copy() {
    test=test_block_copy

    setup
    mkdir ./blocks_to_copy
    dl_mainnet 10 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --log-level debug
    sleep 5

    # start without block 11
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert 10 $best_length
    assert 1 $canonical_length
    assert '3NKGgTk7en3347KH81yDra876GPAUSoSePrfVKPmwR1KHfMpvJC5' $best_hash
    assert '3NKeMoncuHab5ScarV5ViyF16cJPT4taWNSaTLS64Dp67wuXigPZ' $canonical_hash

    # add block 11
    dl_mainnet_single 11 ./blocks_to_copy
    cp ./blocks_to_copy/mainnet-11-3NLMeYAFXxsmhSFtLHFxdtjGcfHTVFmBmBF8uTJvP4Ve5yEmxYeA.json ./blocks
    sleep 1

    # check
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert 11 $best_length
    assert 1 $canonical_length
    assert '3NLMeYAFXxsmhSFtLHFxdtjGcfHTVFmBmBF8uTJvP4Ve5yEmxYeA' $best_hash
    assert '3NKeMoncuHab5ScarV5ViyF16cJPT4taWNSaTLS64Dp67wuXigPZ' $canonical_hash

    teardown
}

# Indexer handles missing blocks correctly
test_missing_blocks() {
    test=test_missing_blocks

    setup
    dl_mainnet 10 ./blocks
    dl_mainnet_range 12 20 ./blocks # missing 11
    dl_mainnet_range 22 30 ./blocks # missing 21

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --log-level debug
    sleep 5

    # start out missing block 11 & 21
    num_dangling=$(idxr summary -j | jq -r .witness_tree.num_dangling)
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert 2 $num_dangling
    assert 10 $best_length
    assert 1 $canonical_length
    assert '3NKGgTk7en3347KH81yDra876GPAUSoSePrfVKPmwR1KHfMpvJC5' $best_hash
    assert '3NKeMoncuHab5ScarV5ViyF16cJPT4taWNSaTLS64Dp67wuXigPZ' $canonical_hash

    # add missing block which connects the dangling branches
    dl_mainnet_single 21 ./blocks
    sleep 1

    # dangling branches combine
    # no new canonical blocks
    num_dangling=$(idxr summary -j | jq -r .witness_tree.num_dangling)
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert 1 $num_dangling
    assert 10 $best_length
    assert 1 $canonical_length
    assert '3NKGgTk7en3347KH81yDra876GPAUSoSePrfVKPmwR1KHfMpvJC5' $best_hash
    assert '3NKeMoncuHab5ScarV5ViyF16cJPT4taWNSaTLS64Dp67wuXigPZ' $canonical_hash

    # add remaining missing block
    dl_mainnet_single 11 ./blocks
    sleep 1

    # dangling branches move into the root branch
    num_dangling=$(idxr summary -j | jq -r .witness_tree.num_dangling)
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert 0 $num_dangling
    assert 30 $best_length
    assert 20 $canonical_length
    assert '3NLsuVoPLnRzdzjrdFKWmkqNzqNEQxrfa7iQMwu1WxcstZjmorUs' $best_hash
    assert '3NLPpt5SyVnD1U5uJAqR3DL1Cqj5dG26SuWutRQ6AQpbQtQUWSYA' $canonical_hash

    teardown
}

# Indexer server returns the correct best chain
test_best_chain() {
    test=test_best_chain

    setup
    mkdir best_chain
    dl_mainnet 12 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    result=$(idxr best-chain -n 1 | jq -r .[0].state_hash)
    assert '3NKkJDmNZGYdKVDDJkkamGdvNzASia2SXxKpu18imps7KqbNXENY' $result

    result=$(idxr best-chain -v | jq -r .[0].state_hash)
    assert '3NKkJDmNZGYdKVDDJkkamGdvNzASia2SXxKpu18imps7KqbNXENY' $result

    # best chain with bounds
    bounds=$(idxr best-chain \
        --start-state-hash 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R \
        --end-state-hash 3NKQUoBfi9vkbuqtDJmSEYBQrcSo4GjwG8bPCiii4yqM8AxEQvtY \
        | jq -r .[0].state_hash)
    assert '3NKQUoBfi9vkbuqtDJmSEYBQrcSo4GjwG8bPCiii4yqM8AxEQvtY' $bounds

    bounds=$(idxr best-chain \
        --start-state-hash '3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R' \
        --end-state-hash '3NKQUoBfi9vkbuqtDJmSEYBQrcSo4GjwG8bPCiii4yqM8AxEQvtY' \
        | jq -r .[1].state_hash)
    assert '3NL9qBsNibXPm5Nh8cSg5CCqrbzX5VUVY9gJzAbg7EVCF3hfhazG' $bounds

    bounds=$(idxr best-chain --start-state-hash '3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R' \
        --end-state-hash '3NKQUoBfi9vkbuqtDJmSEYBQrcSo4GjwG8bPCiii4yqM8AxEQvtY' \
        | jq -r .[2].state_hash)
    assert '3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R' $bounds

    # write best chain to file
    file=./best_chain/best_chain.json
    idxr best-chain -p $file
    file_result=$(cat $file | jq -r .[0].state_hash)
    assert '3NKkJDmNZGYdKVDDJkkamGdvNzASia2SXxKpu18imps7KqbNXENY' $file_result

    idxr best-chain -v -p $file
    file_result=$(cat $file | jq -r .[0].state_hash)
    assert '3NKkJDmNZGYdKVDDJkkamGdvNzASia2SXxKpu18imps7KqbNXENY' $file_result

    rm -rf best_chain
    teardown
}

# Indexer server returns correct ledgers
test_ledgers() {
    test=test_ledgers

    setup
    mkdir ledgers
    dl_mainnet 15 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    pk='B62qp1RJRL7x249Z6sHCjKm1dbkpUWHRdiQbcDaz1nWUGa9rx48tYkR'

    # canonical ledgers match
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_height=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    hash_balance=$(idxr ledger --hash $canonical_hash | jq -r .${pk}.balance)
    height_balance=$(idxr ledger-at-height --height $canonical_height | jq -r .${pk}.balance)
    assert '607904750000000' $hash_balance
    assert '607904750000000' $height_balance

    # best ledgers match
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_height=$(idxr summary -j | jq -r .witness_tree.best_tip_length)

    best_result=$(idxr best-ledger | jq -r .${pk}.balance)
    hash_result=$(idxr ledger --hash $best_hash | jq -r .${pk}.balance)
    height_balance=$(idxr ledger-at-height --height $best_height | jq -r .${pk}.balance)

    assert '607904750000000' $best_result
    assert '607904750000000' $hash_result
    assert '607904750000000' $height_balance

    # write ledgers to file
    file=./ledgers/best-$best_height-$best_hash.json
    idxr best-ledger -p $file
    
    file_result=$(cat $file | jq -r .${pk}.balance)
    assert '607904750000000' $file_result
    rm -f $file

    file=./ledgers/ledger-$best_height-$best_hash.json
    idxr ledger --hash $best_hash -p $file
    
    file_result=$(cat $file | jq -r .${pk}.balance)
    assert '607904750000000' $file_result
    rm -f $file

    file=./ledgers/height-$best_height-$best_hash.json
    idxr ledger-at-height --height $best_height -p $file
    
    file_result=$(cat $file | jq -r .${pk}.balance)
    assert '607904750000000' $file_result
    rm -f $file

    rm -rf ledgers
    teardown
}

# Indexer server syncs with existing Speedb
test_sync() {
    test=test_sync

    setup
    dl_mainnet 15 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # kill running indexer and release db lock
    kill "$(cat idxr_pid)" 2>/dev/null || true
    rm -f idxr_pid
    rm ./database/LOCK

    # add more blocks to the watch dir while not indexing
    dl_mainnet_range 16 20 ./blocks

    # sync from previous indexer db
    idxr_server sync \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # post-sync results
    canonical_hash_sync=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length_sync=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)
    best_hash_sync=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length_sync=$(idxr summary -j | jq -r .witness_tree.best_tip_length)

    # includes blocks added to watch dir while down
    assert 20 $best_length_sync
    assert 10 $canonical_length_sync
    assert '3NLPpt5SyVnD1U5uJAqR3DL1Cqj5dG26SuWutRQ6AQpbQtQUWSYA' $best_hash_sync
    assert '3NKGgTk7en3347KH81yDra876GPAUSoSePrfVKPmwR1KHfMpvJC5' $canonical_hash_sync

    teardown
}

# Indexer server replays events
test_replay() {
    test=test_replay

    setup
    dl_mainnet 15 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # kill running indexer and release db lock
    kill "$(cat idxr_pid)" 2>/dev/null || true
    rm -f idxr_pid
    rm ./database/LOCK

    # add more blocks to the watch dir while not indexing
    dl_mainnet_range 16 20 ./blocks

    # replay events from previous indexer instance
    idxr_server replay \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # post-replay results
    canonical_hash_replay=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length_replay=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)
    best_hash_replay=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length_replay=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    num_blocks_replay=$(idxr summary -j | jq -r .blocks_processed)

    # includes blocks added to watch dir while down
    assert 20 $num_blocks_replay
    assert 20 $best_length_replay
    assert 10 $canonical_length_replay
    assert '3NLPpt5SyVnD1U5uJAqR3DL1Cqj5dG26SuWutRQ6AQpbQtQUWSYA' $best_hash_replay
    assert '3NKGgTk7en3347KH81yDra876GPAUSoSePrfVKPmwR1KHfMpvJC5' $canonical_hash_replay

    teardown
}

# Indexer server returns correct transactions
test_transactions() {
    test=test_transactions

    setup
    mkdir transactions
    dl_mainnet 13 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # basic pk transaction queries
    transactions=$(idxr tx-public-key --public-key B62qp1RJRL7x249Z6sHCjKm1dbkpUWHRdiQbcDaz1nWUGa9rx48tYkR | jq -r .)
    amount=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy | jq -r .[0].Payment.amount)

    assert '1000' $amount
    assert '[]' $transactions

    # basic pk transaction queries - verbose
    kind=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].command.payload.body.kind)
    amount=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].command.payload.body.amount)
    state_hash=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].state_hash)
    tx_hash=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].tx_hash)
    length=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].blockchain_length)

    assert 3 $length
    assert '1000' $amount
    assert 'Payment' $kind
    assert '3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R' $state_hash
    assert 'CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa' $tx_hash

    # bounded pk transaction queries
    amount=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy \
        --start-state-hash 3NL9qBsNibXPm5Nh8cSg5CCqrbzX5VUVY9gJzAbg7EVCF3hfhazG \
        --end-state-hash 3NKXzc1hAE1bK9BSkJUhBBSznMhwW3ZxUTgdoLoqzW6SvqVFcAw5 \
        | jq -r .[0].Payment.amount)
    assert '1000' $amount

    amount=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy \
        --start-state-hash 3NLyWnjZqUECniE1q719CoLmes6WDQAod4vrTeLfN7XXJbHv6EHH \
        --end-state-hash 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R \
        | jq -r .[0].Payment.amount)
    assert '1000' $amount

    # tx hash query
    amount=$(idxr tx-hash --tx-hash CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa | jq -r .Payment.amount)
    assert '1000' $amount

    # tx hash query - verbose
    kind=$(idxr tx-hash -t CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa -v | jq -r .command.payload.body.kind)
    amount=$(idxr tx-hash -t CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa -v | jq -r .command.payload.body.amount)
    status=$(idxr tx-hash -t CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa -v | jq -r .status.kind)
    tx_hash=$(idxr tx-hash -t CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa -v | jq -r .tx_hash)
    state_hash=$(idxr tx-hash -t CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa -v | jq -r .state_hash)
    length=$(idxr tx-hash -t CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa -v | jq -r .blockchain_length)

    assert 3 $length
    assert 'Payment' $kind
    assert '1000' $amount
    assert 'Failed' $status
    assert 'CkpZirFuoLVVab6x2ry4j8Ld5gMmQdak7VHW6f5C7VJYE34WAEWqa' $tx_hash
    assert '3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R' $state_hash

    # state hash query
    amount=$(idxr tx-state-hash --state-hash 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R | jq -r .[0].Payment.amount)
    source=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R | jq -r .[0].Payment.source)
    receiver=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R | jq -r .[0].Payment.receiver)

    assert '1000' $amount
    assert 'B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy' $source
    assert 'B62qjYanmV7y9njVeH5UHkz3GYBm7xKir1rAnoY4KsEYUGLMiU45FSM' $receiver

    # state hash query - verbose
    kind=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R -v | jq -r .[0].data.kind)
    assert 'Signed_command' $kind

    amount=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R -v | jq -r .[0].data.payload.body.amount)
    source=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R -v | jq -r .[0].data.payload.body.source_pk)
    receiver=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R -v | jq -r .[0].data.payload.body.receiver_pk)
    token=$(idxr tx-state-hash -s 3NKd5So3VNqGZtRZiWsti4yaEe1fX79yz5TbfG6jBZqgMnCQQp3R -v | jq -r .[0].data.payload.body.token_id)

    assert '1' $token
    assert '1000' $amount
    assert 'B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy' $source
    assert 'B62qjYanmV7y9njVeH5UHkz3GYBm7xKir1rAnoY4KsEYUGLMiU45FSM' $receiver

    # write transactions to file
    file=./transactions/transactions.json
    idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -p $file
    
    file_result=$(cat $file | jq -r .[0].Payment.amount)
    assert '1000' $file_result

    rm -rf ./transactions
    teardown
}
# Indexer server returns correct SNARK work
test_snark_work() {
    test=test_snark_work

    setup
    mkdir snark_work
    dl_mainnet 120 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # pk SNARK work queries
    # prover has SNARK work in block 111
    fee=$(idxr snark-public-key --public-key B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h | jq -r .[0].fee)
    prover=$(idxr snark-public-key --public-key B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h | jq -r .[0].prover)
    state_hash=$(idxr snark-public-key --public-key B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h | jq -r .[0].state_hash)

    assert '0' $fee
    assert 'B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h' $prover
    assert '3NL33j16AWm3Jhjj1Ud25E54hu7HpUq4WBQcAiijEKMfXqwFJwzK' $state_hash

    # state hash SNARK work queries
    fee=$(idxr snark --state-hash 3NL33j16AWm3Jhjj1Ud25E54hu7HpUq4WBQcAiijEKMfXqwFJwzK | jq -r .[0].fee)
    prover=$(idxr snark --state-hash 3NL33j16AWm3Jhjj1Ud25E54hu7HpUq4WBQcAiijEKMfXqwFJwzK | jq -r .[0].prover)

    assert '0' $fee
    assert 'B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h' $prover

    # write SNARK work from public key to file
    file=./snark_work/snark_work.json
    idxr snark-public-key -k B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h -p $file
    
    fee=$(cat $file | jq -r .[0].fee)
    prover=$(cat $file | jq -r .[0].prover)
    state_hash=$(cat $file | jq -r .[0].state_hash)

    assert '0' $fee
    assert 'B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h' $prover
    assert '3NL33j16AWm3Jhjj1Ud25E54hu7HpUq4WBQcAiijEKMfXqwFJwzK' $state_hash

    # write SNARK work from block to file
    file=./snark_work/snark_work.json
    idxr snark --state-hash 3NL33j16AWm3Jhjj1Ud25E54hu7HpUq4WBQcAiijEKMfXqwFJwzK -p $file
    
    fee=$(cat $file | jq -r .[0].fee)
    prover=$(cat $file | jq -r .[0].prover)

    assert '0' $fee
    assert 'B62qrCz3ehCqi8Pn8y3vWC9zYEB9RKsidauv15DeZxhzkxL3bKeba5h' $prover

    rm -rf ./snark_work
    teardown
}

# Indexer server correctly creates a db checkpoint
test_checkpoint() {
    test=test_checkpoint

    setup
    dl_mainnet 13 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs
    sleep 5

    # pre-checkpoint results
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    amount=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].command.payload.body.amount)

    # create checkpoint in ./checkpoint
    idxr checkpoint -p ./checkpoint

    # kill running indexer and remove directories
    teardown

    # sync a new indexer from checkpointed db
    setup
    idxr_server sync \
        --startup-dir ./blocks \
        --database-dir ./checkpoint \
        --log-dir ./logs
    sleep 5

    # post-checkpoint reults
    canonical_hash_checkpoint=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length_checkpoint=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)
    best_hash_checkpoint=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length_checkpoint=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    amount_checkpoint=$(idxr tx-public-key -k B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy -v | jq -r .[0].command.payload.body.amount)

    assert $canonical_hash $canonical_hash_checkpoint
    assert $canonical_length $canonical_length_checkpoint
    assert $best_hash $best_hash_checkpoint
    assert $best_length $best_length_checkpoint
    assert $amount $amount_checkpoint

    rm -rf ./checkpoint
    teardown
}

# Indexer server starts with many blocks
test_many_blocks() {
    test=test_many_blocks

    setup
    dl_mainnet 1000 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --ledger-cadence 100 \
        --log-level debug
    sleep 10

    # results
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert '1000' $best_length
    assert '990' $canonical_length
    assert '3NK9aySQJBEgAUKcWGrpbZhA4M8wL2N3cjipq3mEb4HPTuUkowEF' $canonical_hash
    assert '3NKrnCRmvomXqor8pnqrUsLv4XcofJBu8VWqAsWRirGNPszo1a66' $best_hash

    pk='B62qpJ4Q5J4LoBXgQBfq6gbXTyevFPhwMNYZEBdTSixmFq4UrdNadSN'

    # check ledgers are present
    # mainnet-100-3NKLtRnMaWAAfRvdizaeaucDPBePPKGbKw64RVcuRFtMMkE8aAD4.json
    balance=$(idxr ledger --hash 3NKLtRnMaWAAfRvdizaeaucDPBePPKGbKw64RVcuRFtMMkE8aAD4 | jq -r .${pk}.balance)
    assert '502777775000000' $balance

    # mainnet-900-3NLHqp2mkmWbf4o69J4hg5cftRAAvZ5Edy7uqvJUUVvZWtD1xRrh.json
    balance=$(idxr ledger --hash 3NLHqp2mkmWbf4o69J4hg5cftRAAvZ5Edy7uqvJUUVvZWtD1xRrh | jq -r .${pk}.balance)
    assert '502777775000000' $balance

    teardown
}

test_rest_endpoints() {
    test=test_rest_endpoints

    port=$(ephemeral_port)

    setup
    dl_mainnet 100 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --log-level debug \
        --web-hostname "0.0.0.0" \
        --web-port "$port"
    sleep 10

    # results
    balance=$(curl -s http://localhost:${port}/accounts/B62qrQBarKiVK11xP943pMQxnmNrfYpT7hskHLWdFXbx2K1E9wR1Vdy | jq -r .balance)
    assert '1439050000000' $balance

    # Testing blockchain summary endpoint
    curl -s http://localhost:${port}/summary > output.json

    blockchain_length=$(cat output.json | jq -r .blockchainLength)
    assert '100' $blockchain_length

    chain_id=$(cat output.json | jq -r .chainId)
    assert '5f704cc0c82e0ed70e873f0893d7e06f148524e3f0bdae2afb02e7819a0c24d1' $chain_id

    circulating_supply=$(cat output.json | jq -r .circulatingSupply)
    assert '89031537.840039233' $circulating_supply

    # date_time=$(cat output.json | jq -r .dateTime)
    # assert 'Wed, 17 Mar 2021 07:15:00 GMT' $date_time

    epoch=$(cat output.json | jq -r .epoch)
    assert '0' $epoch

    global_slot=$(cat output.json | jq -r .globalSlot)
    assert '145' $global_slot

    locked_supply=$(cat output.json | jq -r .lockedSupply)
    assert '716354155' $locked_supply

    min_window_density=$(cat output.json | jq -r .minWindowDensity)
    assert '77' $min_window_density

    next_epoch_ledger_hash=$(cat output.json | jq -r .nextEpochLedgerHash)
    assert 'jx7buQVWFLsXTtzRgSxbYcT8EYLS8KCZbLrfDcJxMtyy4thw2Ee' $next_epoch_ledger_hash

    previous_state_hash=$(cat output.json | jq -r .previousStateHash)
    assert '3NLdywCHZmuqxS4hUnW7Uuu6sr97iifh5Ldc6m9EbzVZyLqbxqCh' $previous_state_hash

    slot=$(cat output.json | jq -r .slot)
    assert '145' $slot

    snarked_ledger_hash=$(cat output.json | jq -r .snarkedLedgerHash)
    assert 'jx7buQVWFLsXTtzRgSxbYcT8EYLS8KCZbLrfDcJxMtyy4thw2Ee' $snarked_ledger_hash

    staged_ledger_hash=$(cat output.json | jq -r .stagedLedgerHash)
    assert 'jwWHNKQPdgLxHCsBki57a6zBfNPUFkAQmsrCNq3E7Q8oiNCNdkm' $staged_ledger_hash

    staking_epoch_ledger_hash=$(cat output.json | jq -r .stakingEpochLedgerHash)
    assert 'jx7buQVWFLsXTtzRgSxbYcT8EYLS8KCZbLrfDcJxMtyy4thw2Ee' $staking_epoch_ledger_hash

    state_hash=$(cat output.json | jq -r .stateHash)
    assert '3NKLtRnMaWAAfRvdizaeaucDPBePPKGbKw64RVcuRFtMMkE8aAD4' $state_hash

    total_currency=$(cat output.json | jq -r .totalCurrency)
    assert '805385692.840039233' $total_currency

    check-jsonschema --schemafile "$SUMMARY_SCHEMA" output.json

    teardown
}

# Release version is fast
test_release() {
    test=test_release

    setup
    dl_mainnet 5000 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --log-level debug
    sleep 30

    # results
    best_hash=$(idxr summary -j | jq -r .witness_tree.best_tip_hash)
    best_length=$(idxr summary -j | jq -r .witness_tree.best_tip_length)
    canonical_hash=$(idxr summary -j | jq -r .witness_tree.canonical_tip_hash)
    canonical_length=$(idxr summary -j | jq -r .witness_tree.canonical_tip_length)

    assert '5000' $best_length
    assert '4990' $canonical_length
    assert '3NKiyxhxfohCGpHkQg7TC1cNxHzAHbcHCUAdSM1aNt2u6dGtVrvC' $canonical_hash
    assert '3NLn1bsWFjycHNJGGLy3KSxXSW6ixmFrunn1iym5GWjTXxkt6oFi' $best_hash

    pk='B62qpJ4Q5J4LoBXgQBfq6gbXTyevFPhwMNYZEBdTSixmFq4UrdNadSN'

    # check ledgers are present
    # mainnet-100-3NKLtRnMaWAAfRvdizaeaucDPBePPKGbKw64RVcuRFtMMkE8aAD4.json
    balance=$(idxr ledger --hash 3NKLtRnMaWAAfRvdizaeaucDPBePPKGbKw64RVcuRFtMMkE8aAD4 | jq -r .${pk}.balance)
    assert '502777775000000' $balance

    # mainnet-900-3NLHqp2mkmWbf4o69J4hg5cftRAAvZ5Edy7uqvJUUVvZWtD1xRrh.json
    balance=$(idxr ledger --hash 3NLHqp2mkmWbf4o69J4hg5cftRAAvZ5Edy7uqvJUUVvZWtD1xRrh | jq -r .${pk}.balance)
    assert '502777775000000' $balance

    teardown
}

test_genesis_block_creator() {
    test=test_genesis_block_creator

    setup

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --log-level debug
    sleep 5
    
    pk=B62qiy32p8kAKnny8ZFwoMhYpBppM1DWVCqAPBYNcXnsAHhnfAAuXgg
    balance=$(idxr ledger-at-height --height 1 | jq -r .${pk}.balance)
    
    # verify that the genesis block winner account gets 1000 magic nanomina
    assert '1000' $balance

    teardown
}

test_txn_nonces() {
    test=test_txn_nonces

    setup
    dl_mainnet 100 ./blocks

    idxr_server_start \
        --startup-dir ./blocks \
        --database-dir ./database \
        --log-dir ./logs \
        --log-level debug
    sleep 5

    pk=B62qre3erTHfzQckNuibViWQGyyKwZseztqrjPZBv6SQF384Rg6ESAy

    # verify that the nonce matches what's reported from the archive node

    # after block 3
    nonce=$(idxr ledger-at-height -h 3 | jq -r .${pk}.nonce)
    assert '4' $nonce

    # after block 3
    nonce=$(idxr account -k $pk | jq -r .nonce)
    assert '149' $nonce

    teardown
}

# Check command-line arguments
if [ "$#" -eq 0 ]; then
    # No arguments provided, run all tests
    test_indexer_cli_reports
    test_server_startup
    test_ipc_is_available_immediately
    test_startup_dirs_get_created
    test_account_balance_cli
    test_account_public_key_json
    test_canonical_tip
    test_canonical_threshold
    test_best_tip
    test_blocks
    test_block_copy
    test_missing_blocks
    test_best_chain
    test_ledgers
    test_sync
    test_replay
    test_transactions
    test_snark_work
    test_checkpoint
    test_rest_endpoints
    test_genesis_block_creator
    test_txn_nonces
    test_many_blocks
else
    # Run only specified tests
    for test_name in "$@"; do
        case $test_name in
            "test_indexer_cli_reports") test_indexer_cli_reports ;;
            "test_server_startup") test_server_startup ;;
            "test_ipc_is_available_immediately") test_ipc_is_available_immediately ;;
            "test_startup_dirs_get_created") test_startup_dirs_get_created ;;
            "test_account_balance_cli") test_account_balance_cli ;;
            "test_account_public_key_json") test_account_public_key_json ;;
            "test_canonical_tip") test_canonical_tip ;;
            "test_canonical_threshold") test_canonical_threshold ;;
            "test_best_tip") test_best_tip ;;
            "test_blocks") test_blocks ;;
            "test_block_copy") test_block_copy ;;
            "test_missing_blocks") test_missing_blocks ;;
            "test_best_chain") test_best_chain ;;
            "test_ledgers") test_ledgers ;;
            "test_sync") test_sync ;;
            "test_replay") test_replay ;;
            "test_transactions") test_transactions ;;
            "test_snark_work") test_snark_work ;;
            "test_checkpoint") test_checkpoint ;;
            "test_rest_endpoints") test_rest_endpoints ;;
            "test_genesis_block_creator") test_genesis_block_creator ;;
            "test_txn_nonces") test_txn_nonces ;;
            "test_many_blocks") test_many_blocks ;;
            "test_release") test_release ;;
            *) echo "Unknown test: $test_name" ;;
        esac
    done
fi

echo "Done"
